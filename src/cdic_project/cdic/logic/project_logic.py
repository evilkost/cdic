# coding: utf-8
import datetime
from io import StringIO
import json
import os
import logging

import arrow

from backports.typing import Iterable, List
from flask import abort
from flask_wtf import Form
from sqlalchemy.orm.query import Query
from sqlalchemy.sql import true, or_, and_
from sqlalchemy.orm.exc import NoResultFound

from .. import db, git_store
from ..util.git import AnotherRepoExists
from ..constants import SourceType, EventType
from ..exceptions import PatchDockerfileException
from ..models import Project, User
from .event_logic import create_project_event

log = logging.getLogger(__name__)

BEGIN_CDIC_SECTION = ("### DOPR START, code until tag `DOPR END`"
                      " was auto-generated by dopr service\n\n")
END_CDIC_SECTION = "### DOPR END\n\n"


class ProjectLogic(object):

    @classmethod
    def get_project_by_id(cls, ident: int) -> Project:
        """
        :raises NoResultFound: when no such project exists
        """
        return Project.query.get(ident)

    @classmethod
    def get_project_by_id_safe(
            cls, project_id: int,
            hide_removed: bool=True) -> Project:  # or None

        try:
            project = cls.query_project_by_id(project_id).one()
        except NoResultFound:
            return None

        if hide_removed and project.delete_requested_on is not None:
            return None
        else:
            return project

    @classmethod
    def get_project_by_title(cls, user: User, title: str) -> Project:
        """
        :raises NoResultFound: when no such project exists
        """
        return Project.query.filter(Project.user_id == user.id).filter_by(title=title).one()


    @classmethod
    def query_project_by_id(cls, project_id: int) -> Query:
        """
        :raises NoResultFound: when no such project exists
        """
        return Project.query.filter(Project.id == project_id)

    @classmethod
    def query_all_ready_projects(cls) -> Query:
        """
        :return: All projects which is not deleted and already have GH and DH repos ready
        """
        return (
            Project.query
            .join(User)
            .filter(Project.github_repo_exists)
            .filter(Project.dockerhub_repo_exists)
            .filter(Project.delete_requested_on.is_(None))
        )

    @classmethod
    def query_by_owner(cls, username: str):
        query = cls.query_all_ready_projects()
        return query.filter(User.username == username)

    @classmethod
    def get_projects_to_run_build_again(cls) -> List[Project]:
        delay = datetime.timedelta(seconds=60)  # seconds, todo: move to config
        old_enough = arrow.utcnow() - delay
        projects = (
            cls.query_all_ready_projects()
            .filter(Project.build_requested_on.isnot(None))
            .filter(Project.build_requested_on < old_enough)
            .filter(or_(
                Project.build_triggered_on.is_(None),
                Project.build_triggered_on < Project.build_requested_on
            ))
        ).all()
        return projects

    @classmethod
    def get_projects_repo_creation_not_done(cls) -> List[Project]:
        delay = datetime.timedelta(seconds=60)  # seconds, todo: move to config
        old_enough = arrow.utcnow() - delay
        query = (
            Project.query
            .filter(Project.created_on < old_enough)
            .filter(Project.dh_build_trigger_url.is_(None))
        )
        projects = query.all()

        return projects

    @classmethod
    def update_dockerfile(cls, project: Project, silent=True):
        ProjectLogic.update_patched_dockerfile(project)
        if not silent:
            build_event = create_project_event(
                project, "Started new build",
                data_json=json.dumps({"build_requested_dt": arrow.utcnow().isoformat()}),
                event_type=EventType.BUILD_REQUESTED
            )
            db.session.add(build_event)
        db.session.add(project)

    @classmethod
    def should_commit_changes(cls, p: Project):
        if p.patched_dockerfile_on is None:
            return False
        elif p.local_repo_changed_on is None:
            return True
        else:
            return p.patched_dockerfile_on > p.local_repo_changed_on

    @classmethod
    def should_push_changes(cls, p: Project):
        if p.local_repo_changed_on is None:
            return False
        elif p.local_repo_pushed_on is None:
            return True
        else:
            return p.local_repo_changed_on > p.local_repo_pushed_on

    @classmethod
    def should_send_build_trigger(cls, p: Project):
        if p.build_requested_on is None:
            return False
        elif p.local_repo_pushed_on is None:
            return False
        elif p.build_triggered_on is None:
            return True
        else:
            return p.build_triggered_on < p.build_requested_on

    @classmethod
    def init_local_repo(cls, project: Project):
        # TODO: this function should be placed outside from Logic
        log.info("going to init local repo")
        if project.source_mode == SourceType.LOCAL_TEXT:
            try:
                repo = git_store.init_local(project.user.username, project.title)
            except AnotherRepoExists:
                return

            git_store.add_remote(repo, project.github_push_url)
            open(os.path.join(repo.working_dir, "Dockerfile"), "wb").close()  # touch Dockerfile
            git_store.initial_commit(repo, ["Dockerfile"])

            project.local_repo_exists = True

            pe = create_project_event(project, "Created local repo")
            db.session.add_all([pe, project])

        else:
            raise NotImplementedError("Init of local repo for source mode: {} "
                                      "not implemented".format(project.source_mode))

    @classmethod
    def get_projects_to_delete(cls):
        return Project.query.filter(Project.delete_requested_on.isnot(None)).all()

    @classmethod
    def exists_for_user(cls, user: User, title: str) -> bool:
        try:
            ProjectLogic.get_project_by_title(user, title)
            return True
        except NoResultFound:
            return False

    @classmethod
    def path_dockerfile_for_project(cls, project: Project, dockerfile: str=None) -> str:
        dockerfile = dockerfile or ""
        coprs_names = [lc.full_name for lc in project.linked_coprs]  # type: List[str]
        return cls.patch_dockerfile(coprs_names, dockerfile)

    @classmethod
    def patch_dockerfile(cls, copr_names: Iterable[str], dockerfile: str) -> str:

        out = StringIO()
        before_from = True

        def write_copr_enabler():
            out.write(BEGIN_CDIC_SECTION)
            out.write("RUN yum install -y dnf dnf-plugins-core \\\n"
                      "    && mkdir -p /etc/yum.repos.d/\n")
            if copr_names:
                out.write("RUN ")

                out.write(" && \\\n    ".join([
                    "dnf copr enable -y {}".format(copr)
                    for copr in copr_names
                ]))
            # out.write("\n")
            # out.write("RUN dnf clean all\n")
            out.write("\n")
            out.write(END_CDIC_SECTION)

        for raw_line in dockerfile.split(os.linesep):
            line = raw_line.strip()
            if not line:
                continue

            if line.startswith("FROM"):
                if before_from:
                    before_from = False
                    out.write("{}\n".format(line))
                    write_copr_enabler()
                else:
                    raise PatchDockerfileException("Unexpected command, "
                                                   "encountered FROM command twice")

            else:
                if before_from:
                    raise PatchDockerfileException("Unexpected command, Dockerfile "
                                                   "should start with FROM command")
                else:
                    out.writelines("{}\n".format(line))
        return out.getvalue()

    @classmethod
    def update_patched_dockerfile(cls, project: Project):
        # TODO: should be called auto-magically
        if project.source_mode == SourceType.LOCAL_TEXT:
            patched = cls.path_dockerfile_for_project(project, project.local_text)
        else:
            raise NotImplementedError("Dockerfile patching for {} not implemented yet"
                                      .format(project.source_mode))

        project.patched_dockerfile = patched
        project.patched_dockerfile_on = arrow.utcnow()
        return project

    @classmethod
    def delete_project_with_events(cls, p: Project):
        for pe in p.history_events:
            db.session.delete(pe)
        db.session.delete(p)
